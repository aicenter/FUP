<h1 id="filetree-scheme">2. Filetree [Scheme]</h1>
<p>A filetree can be used to efficiently search/replace in large filesystems. You can think of it as a tree with a variable size of nodes</p>
<pre><code>.
├── README.md
├── scripts
│   ├── experimental
│   ├── task1.ss
│   ├── task2.ss
│   ├── task3.hs
│   └── task4.hs
└── src
    ├── complex.hs
    └── ftree.ss</code></pre>
<p>We define a Filetree as either an empty list or a list containing lists of values, where each value is a key for a filetree. The value-key and the corresponding filetree are contained in the same list, one after the other. We can write <code>(define empty-ftree '())</code> or <code>(define tree ((key_1 subtree_1) ... (key_n subtree_n)))</code>. In this formulation a leaf is a value that is key for an empty list. We can then use filetrees to model a filesystem. The exercise consists in parsing a list of file paths (directories separated by <code>/</code>), input as strings, into a filetree through a function <code>(parse paths)</code>. In the example above the root node of the tree contains two directories <code>scripts</code> and <code>src</code>, as well as a file <code>README.md</code>. The corresponding <code>FNode</code> would therefore look like this:</p>
<pre><code>(list (&quot;README&quot; emtpy-tree)
      (&quot;scripts&quot; (list ...)
      (&quot;src&quot; (list ...))))
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>In Scheme, you are given a list of files (directories separated by <code>/</code>) like this:</p>
<pre><code>(list &quot;src/tree.hs&quot;
      &quot;src/complex.hs&quot;
      &quot;scripts/ex1/test.ss&quot;
      &quot;scripts/ex1/eval.ss&quot;
      &quot;scripts/emptydir&quot;
      &quot;scripts/ex2/test.ss&quot;
      &quot;tests/test_tree.hs&quot;))</code></pre>
<p>Parse the list of files into a tree and check if a new file or directory is already in the tree with the function</p>
<pre><code>(exists file tree)</code></pre>
<h2 id="hints">Hints</h2>
<p>For splitting a string into a list of strings you can make use of the functions</p>
<pre><code>(define (head str) (substring str 0 1))

(define (tail str) (substring str 1 (string-length str)))

;; Splits a string in two parts at the first ocurrence of `ch`
;;
;; Example:
;; &gt; (split-hlp &quot;&quot; &quot;path/with/sub/dirs/file.txt&quot; &quot;/&quot;)
;; &#39;(&quot;path&quot;, &quot;with/sub/dirs/file.txt&quot;)
(define (split-hlp d str ch)
  (cond ((equal? str &quot;&quot;) (list d str))
        ((equal? (head str) ch) (list d (tail str)))
        (else (split-hlp (string-append d (head str)) (tail str) ch))))</code></pre>
<p>You can define a function <code>(find-ftree key ftree)</code> that, given a filetree and a key returns the corresponding subtree:</p>
<pre><code>(define ftree &#39;((&quot;scripts&quot; ((&quot;ex1&quot; ((&quot;test.ss&quot; &#39;())))))))
(find-ftree &quot;scripts&quot; ftree)
&gt; &#39;((&quot;ex1&quot; ((&quot;test.ss&quot; &#39;()))))</code></pre>
<p>You can define a function <code>(replace-ftree key new_branch ftree)</code> that, given a filetree <code>ftree</code>, a key and a new subtree new_branch, replaces the subtree corresponding to <code>key</code> in <code>ftree</code> with <code>new_branch</code></p>
<pre><code>(define subtree &#39;((&quot;ex1&quot; ((&quot;complex.ss&quot; &#39;())))))
(replace-ftree &quot;ex1&quot; subtree ftree)
&gt; &#39;((&quot;scripts&quot; ((&quot;ex1&quot; ((&quot;complex.ss&quot; &#39;()))))))</code></pre>
<h2 id="example">Example</h2>
<pre><code>(exists &quot;src/tree.hs&quot; (parse files))
&gt; #t

(exists &quot;src/test.hs&quot; (parse files))
&gt; #f</code></pre>
